<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PhotoNest</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600;700&family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #f2f5fb;
  --panel: rgba(255, 255, 255, 0.72);
  --surface: rgba(255, 255, 255, 0.88);
  --line: rgba(21, 32, 58, 0.09);
  --line-strong: rgba(21, 32, 58, 0.16);
  --text: #0e1a31;
  --muted: #66758e;
  --accent: #0a84ff;
  --accent-soft: rgba(10, 132, 255, 0.14);
  --ok: #10b981;
  --warn: #f59e0b;
  --radius-xl: 26px;
  --radius-lg: 20px;
  --radius-md: 14px;
  --shadow: 0 18px 50px rgba(15, 30, 64, 0.13);
  --shadow-card: 0 12px 26px rgba(15, 30, 64, 0.08);
}

* { box-sizing: border-box; }

body {
  margin: 0;
  color: var(--text);
  font-family: "Outfit", "Noto Sans SC", sans-serif;
  background:
    radial-gradient(1000px 500px at -15% -10%, #d6ebff 0%, transparent 62%),
    radial-gradient(1100px 580px at 120% 110%, #d7f8e8 0%, transparent 65%),
    linear-gradient(180deg, #f7f9fd 0%, #eef3fb 100%);
  min-height: 100vh;
}

.shell {
  max-width: 1600px;
  margin: 0 auto;
  padding: 14px 18px 38px;
}

.topbar {
  position: sticky;
  top: 12px;
  z-index: 30;
  border-radius: 22px;
  border: 1px solid var(--line);
  background: var(--panel);
  backdrop-filter: blur(14px) saturate(1.15);
  box-shadow: var(--shadow);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  padding: 10px 12px;
}

.brand {
  display: flex;
  align-items: center;
  gap: 11px;
  min-width: 0;
}

.brand-logo {
  width: 36px;
  height: 36px;
  border-radius: 11px;
  box-shadow: 0 8px 18px rgba(10, 132, 255, 0.24);
  flex-shrink: 0;
}

.brand-title {
  font-size: 19px;
  font-weight: 650;
  letter-spacing: -0.02em;
}

.brand-sub {
  color: var(--muted);
  font-size: 12px;
  margin-top: -1px;
}

.controls {
  display: flex;
  align-items: center;
  gap: 9px;
  flex-wrap: wrap;
  justify-content: flex-end;
}

.search {
  height: 38px;
  width: min(260px, 46vw);
  border: 1px solid var(--line);
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.92);
  padding: 0 14px;
  font-size: 13px;
  color: var(--text);
  outline: none;
}

.search:focus {
  border-color: rgba(10, 132, 255, 0.4);
  box-shadow: 0 0 0 4px rgba(10, 132, 255, 0.11);
}

.badge {
  border-radius: 999px;
  border: 1px solid var(--line);
  background: rgba(255, 255, 255, 0.9);
  color: var(--muted);
  font-size: 12px;
  padding: 8px 11px;
  white-space: nowrap;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 999px;
  display: inline-block;
  margin-right: 6px;
  background: var(--ok);
}

.btn {
  height: 38px;
  border: 1px solid var(--line);
  border-radius: 11px;
  background: rgba(255, 255, 255, 0.92);
  color: var(--text);
  padding: 0 13px;
  font-size: 13px;
  font-family: inherit;
  cursor: pointer;
  transition: transform .15s ease, box-shadow .15s ease, border-color .15s ease;
}

.btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 7px 16px rgba(15, 30, 64, 0.1);
  border-color: var(--line-strong);
}

.btn.primary {
  border: none;
  color: white;
  background: linear-gradient(180deg, #2494ff, #0a84ff);
}

.btn.primary:hover {
  box-shadow: 0 10px 20px rgba(10, 132, 255, 0.28);
}

.content-wrap {
  margin-top: 16px;
}

.breadcrumb {
  margin: 0 2px 12px;
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 8px;
  color: var(--muted);
  font-size: 13px;
}

.breadcrumb .clickable {
  cursor: pointer;
  color: #22324f;
}

.panel {
  border: 1px solid var(--line);
  border-radius: var(--radius-xl);
  background: var(--panel);
  backdrop-filter: blur(12px);
  box-shadow: var(--shadow);
  padding: 18px;
}

.panel-head {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  gap: 10px;
  margin-bottom: 14px;
}

.title {
  font-size: 29px;
  font-weight: 700;
  letter-spacing: -0.03em;
  line-height: 1.08;
}

.subtitle {
  margin-top: 5px;
  color: var(--muted);
  font-size: 13px;
}

.grid {
  display: grid;
  gap: 14px;
}

.grid.years {
  grid-template-columns: repeat(auto-fill, minmax(210px, 1fr));
}

.grid.albums {
  grid-template-columns: repeat(auto-fill, minmax(245px, 1fr));
}

.card {
  border-radius: var(--radius-lg);
  overflow: hidden;
  border: 1px solid var(--line);
  background: var(--surface);
  box-shadow: var(--shadow-card);
  cursor: pointer;
  transition: transform .2s ease, box-shadow .2s ease, border-color .2s ease;
}

.card:hover {
  transform: translateY(-3px);
  box-shadow: 0 18px 32px rgba(15, 30, 64, 0.14);
  border-color: var(--line-strong);
}

.cover {
  background:
    linear-gradient(140deg, #eef5ff, #f8fbff),
    linear-gradient(180deg, rgba(255, 255, 255, 0.84), rgba(255, 255, 255, 0.84));
  border-bottom: 1px solid var(--line);
  min-height: 0;
  aspect-ratio: 16 / 10;
  position: relative;
  padding: 8px;
}

.cover img {
  width: 100%;
  height: 100%;
  display: block;
  border-radius: 12px;
  object-fit: cover;
  object-position: center center;
}

.cover-placeholder {
  min-height: 100%;
  height: 100%;
  border-radius: 12px;
  border: 1px dashed rgba(45, 79, 140, 0.22);
  display: grid;
  place-items: center;
  color: #7b8ba7;
  font-size: 13px;
}

.tag {
  position: absolute;
  top: 14px;
  right: 14px;
  padding: 5px 9px;
  font-size: 11px;
  border-radius: 999px;
  color: white;
  backdrop-filter: blur(5px);
}

.card-body {
  padding: 12px 12px 14px;
}

.name {
  font-size: 14px;
  font-weight: 620;
  letter-spacing: -0.01em;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.meta {
  margin-top: 5px;
  color: var(--muted);
  font-size: 12px;
}

.folder-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  gap: 12px;
  margin-bottom: 12px;
}

.folder-card .cover {
  aspect-ratio: 16 / 9;
}

.photo-masonry {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
  gap: 12px;
  align-items: start;
}

.photo-tile {
  border: 1px solid var(--line);
  border-radius: 14px;
  overflow: hidden;
  background: var(--surface);
  box-shadow: var(--shadow-card);
  cursor: pointer;
  transition: transform .18s ease, box-shadow .18s ease;
  display: flex;
  flex-direction: column;
  min-width: 0;
}

.photo-tile:hover {
  transform: translateY(-2px);
  box-shadow: 0 16px 28px rgba(15, 30, 64, 0.12);
}

.photo-frame {
  background: linear-gradient(145deg, #f3f8ff, #fbfcff);
  border-bottom: 1px solid var(--line);
  aspect-ratio: 4 / 3;
  min-height: 150px;
  overflow: hidden;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.photo-frame img {
  width: 100%;
  height: 100%;
  display: block;
  object-fit: cover;
  object-position: center center;
}

.photo-frame.loading img {
  opacity: 0;
}

.photo-frame.loading::after {
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(
    110deg,
    rgba(255, 255, 255, 0.04) 8%,
    rgba(255, 255, 255, 0.3) 18%,
    rgba(255, 255, 255, 0.04) 33%
  );
  transform: translateX(-100%);
  animation: photo-shimmer 1.3s ease-in-out infinite;
}

.photo-frame.failed::after {
  content: "缩略图加载失败";
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  color: #7f8da5;
  font-size: 12px;
  white-space: nowrap;
}

.photo-frame.failed img {
  display: none;
}

@keyframes photo-shimmer {
  100% { transform: translateX(100%); }
}

.photo-meta {
  padding: 6px 8px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.photo-filename {
  flex: 1;
  min-width: 0;
  font-size: 11px;
  font-weight: 580;
  color: #1e2b44;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.photo-size {
  margin-top: 0;
  white-space: nowrap;
  padding: 1px 6px;
  border-radius: 999px;
  border: 1px solid rgba(73, 102, 152, 0.18);
  background: rgba(242, 247, 255, 0.86);
  color: var(--muted);
  font-size: 10px;
}

.load-more {
  margin-top: 14px;
  text-align: center;
}

.empty {
  text-align: center;
  padding: 58px 20px;
  color: var(--muted);
  font-size: 14px;
}

.lightbox {
  position: fixed;
  inset: 0;
  z-index: 999;
  display: none;
  background: rgba(9, 13, 22, 0.93);
  backdrop-filter: blur(14px);
}

.lightbox.show {
  display: flex;
}

.lb-main {
  margin: auto;
  width: 94vw;
  max-width: 1500px;
  height: 94vh;
  max-height: 980px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.lb-head {
  color: rgba(255, 255, 255, 0.92);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.lb-title {
  font-size: 14px;
}

.lb-actions {
  display: flex;
  gap: 8px;
}

.lb-btn {
  border: 1px solid rgba(255, 255, 255, 0.2);
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  border-radius: 10px;
  height: 34px;
  padding: 0 12px;
  font-family: inherit;
  cursor: pointer;
}

.lb-stage {
  position: relative;
  flex: 1 1 auto;
  min-height: 0;
  border-radius: 18px;
  overflow: hidden;
  background: rgba(255, 255, 255, 0.06);
}

.lb-stage-media {
  position: absolute;
  inset: 0;
  padding: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.lb-stage img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  object-position: center center;
  display: block;
}

.lb-stage-msg {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  color: rgba(255, 255, 255, 0.88);
  font-size: 14px;
  pointer-events: none;
  user-select: none;
}

.lb-stage.loading #lb-img {
  visibility: hidden;
}

.lb-stage.ready #lb-img,
.lb-stage.error #lb-img {
  visibility: visible;
}

.lb-stage.ready .lb-stage-msg {
  display: none;
}

.lb-stage.error .lb-stage-msg {
  color: rgba(255, 170, 170, 0.95);
}

.lb-nav {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  z-index: 2;
  width: 42px;
  height: 42px;
  border: none;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.16);
  color: white;
  font-size: 24px;
  cursor: pointer;
}

.lb-nav.prev { left: 12px; }
.lb-nav.next { right: 12px; }

@media (max-width: 1400px) {
  .photo-masonry { grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); }
}

@media (max-width: 1100px) {
  .photo-masonry { grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); }
}

@media (max-width: 820px) {
  .shell { padding: 10px 10px 28px; }
  .topbar { top: 8px; }
  .panel { padding: 13px; }
  .title { font-size: 23px; }
  .search { width: min(190px, 56vw); }
  .photo-masonry { grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); }
}

@media (max-width: 560px) {
  .controls { gap: 7px; }
  .photo-masonry { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<div class="shell">
  <header class="topbar">
    <div class="brand">
      <img class="brand-logo" src="/static/photonest-logo.svg" alt="PhotoNest logo">
      <div>
        <div class="brand-title">PhotoNest</div>
        <div class="brand-sub">Private Gallery</div>
      </div>
    </div>

    <div class="controls">
      <input id="search" class="search" placeholder="搜索项目名（如 徒步班 / 250110）">
      <span class="badge" id="stats">加载中...</span>
      <span class="badge"><span class="status-dot"></span><span id="user-info"></span></span>
      <button id="admin-btn" class="btn" style="display:none;" onclick="goAdmin()">管理后台</button>
      <button id="refresh-btn" class="btn" style="display:none;" onclick="triggerScan()">增量扫描</button>
      <span class="badge" id="scan-live" style="display:none;">扫描空闲</span>
      <button id="logout-btn" class="btn" onclick="logout()">退出</button>
    </div>
  </header>

  <div class="content-wrap">
    <div class="breadcrumb" id="breadcrumb"></div>

    <section class="panel">
      <div class="panel-head">
        <div>
          <div class="title" id="title">PhotoNest</div>
          <div class="subtitle" id="subtitle"></div>
        </div>
      </div>
      <div id="content"></div>
    </section>
  </div>
</div>

<div class="lightbox" id="lightbox">
  <div class="lb-main">
    <div class="lb-head">
      <div class="lb-title" id="lb-title"></div>
      <div class="lb-actions">
        <button class="lb-btn" onclick="downloadCurrent()">下载原图</button>
        <button class="lb-btn" onclick="closeLightbox()">关闭</button>
      </div>
    </div>
    <div class="lb-stage ready" id="lb-stage">
      <button class="lb-nav prev" onclick="stepLightbox(-1)">&#8249;</button>
      <div class="lb-stage-media">
        <img id="lb-img" alt="preview">
      </div>
      <div class="lb-stage-msg" id="lb-stage-msg">加载预览中...</div>
      <button class="lb-nav next" onclick="stepLightbox(1)">&#8250;</button>
    </div>
    <div class="lb-head">
      <div class="lb-title" id="lb-counter"></div>
      <div></div>
    </div>
  </div>
</div>

<script>
const CURRENT_USER = {{ user | tojson }};

const state = {
  view: 'years',
  year: '',
  albumId: null,
  albumName: '',
  folderPath: '',
  years: [],
  albums: [],
  photos: [],
  page: 1,
  pageSize: 72,
  hasMore: false,
  loading: false,
  query: '',
  lightboxIndex: -1,
  lightboxRenderToken: '',
  lightboxOpen: false,
  tileVisibleQueue: [],
  tilePrefetchQueue: [],
  lightboxPrefetchQueue: [],
  inflightTileTasks: new Map(),
  suspendedByLightbox: new Set(),
  lightboxPreviewCache: new Map(),
  lightboxPreviewOrder: [],
  lightboxMainController: null,
  lightboxPrefetchController: null,
  lightboxPrefetchInFlight: 0,
  lightboxPlaceholderSrc: '',
};

const NETWORK_PROFILE = (() => {
  const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {};
  const effectiveType = String(conn.effectiveType || '').toLowerCase();
  const saveData = Boolean(conn.saveData);
  if (saveData || effectiveType.includes('2g')) {
    return { name: '2g', maxTileConcurrency: 4, prefetchMargin: 300 };
  }
  if (effectiveType === '3g') {
    return { name: '3g', maxTileConcurrency: 6, prefetchMargin: 600 };
  }
  return { name: 'fast', maxTileConcurrency: 8, prefetchMargin: 1000 };
})();

const TILE_VISIBLE_ROOT_MARGIN = '180px 0px';
const TILE_PREFETCH_ROOT_MARGIN = `${NETWORK_PROFILE.prefetchMargin}px 0px`;
const TILE_VISIBLE_RESERVED_SLOTS = 2;
const LIGHTBOX_TILE_BACKGROUND_LIMIT = 2;
const TILE_RETRY_DELAY_MS = 300;
const LIGHTBOX_PREFETCH_CACHE_LIMIT = 6;
const LIGHTBOX_PREFETCH_CONCURRENCY = 1;
const TILE_EAGER_COUNT = 24;

const tileTaskByImg = new WeakMap();

function tileConcurrencyLimit() {
  return state.lightboxOpen ? LIGHTBOX_TILE_BACKGROUND_LIMIT : NETWORK_PROFILE.maxTileConcurrency;
}

function removeTaskFromQueue(queue, task) {
  const idx = queue.indexOf(task);
  if (idx >= 0) queue.splice(idx, 1);
}

function taskDistancePx(task) {
  if (!task?.img) return Number.POSITIVE_INFINITY;
  const rect = task.img.getBoundingClientRect();
  const vh = window.innerHeight || document.documentElement.clientHeight || 1;
  if (rect.bottom < 0) return Math.abs(rect.bottom);
  if (rect.top > vh) return rect.top - vh;
  return 0;
}

function isTaskVisible(task) {
  if (!task?.img) return false;
  const rect = task.img.getBoundingClientRect();
  const vh = window.innerHeight || document.documentElement.clientHeight || 1;
  return rect.bottom >= 0 && rect.top <= vh;
}

function enqueueTileTask(task, priority = 'prefetch', toFront = false) {
  if (!task) return;
  if (task.state === 'done' || task.state === 'failed') return;
  task.distancePx = taskDistancePx(task);
  if (task.state === 'loading') {
    if (priority === 'visible') task.priority = 'visible';
    return;
  }
  removeTaskFromQueue(state.tileVisibleQueue, task);
  removeTaskFromQueue(state.tilePrefetchQueue, task);
  task.priority = priority === 'visible' ? 'visible' : 'prefetch';
  task.state = 'queued';
  task.queuedAt = Date.now();
  if (task.priority === 'visible') {
    if (toFront) {
      state.tileVisibleQueue.unshift(task);
    } else {
      state.tileVisibleQueue.push(task);
    }
    state.suspendedByLightbox.delete(task);
  } else {
    state.tilePrefetchQueue.push(task);
  }
  scheduleTileLoads();
}

function promoteTileTask(task) {
  enqueueTileTask(task, 'visible', true);
}

function suspendTileTask(task) {
  if (!task || task.state !== 'loading') return false;
  if (task.priority === 'visible') return false;
  const img = task.img;
  const frame = task.frame;
  task.runToken = '';
  if (task.retryTimer) {
    clearTimeout(task.retryTimer);
    task.retryTimer = null;
  }
  img.onload = null;
  img.onerror = null;
  try {
    img.src = '';
  } catch (_e) {}
  if (frame) frame.classList.remove('loading');
  state.inflightTileTasks.delete(img);
  task.state = 'idle';
  task.retryCount = 0;
  state.suspendedByLightbox.add(task);
  return true;
}

function suspendLowPriorityTilesForLightbox() {
  const limit = tileConcurrencyLimit();
  if (state.inflightTileTasks.size <= limit) return;
  const candidates = Array.from(state.inflightTileTasks.values())
    .filter((task) => task.priority !== 'visible' && !isTaskVisible(task))
    .sort((a, b) => taskDistancePx(b) - taskDistancePx(a));
  while (state.inflightTileTasks.size > limit && candidates.length > 0) {
    const task = candidates.shift();
    if (!task) break;
    suspendTileTask(task);
  }
  scheduleTileLoads();
}

function restoreSuspendedTiles() {
  if (!state.suspendedByLightbox.size) return;
  const tasks = Array.from(state.suspendedByLightbox);
  state.suspendedByLightbox.clear();
  for (const task of tasks) {
    if (task?.state === 'idle') {
      enqueueTileTask(task, task.priority === 'visible' ? 'visible' : 'prefetch');
    }
  }
  scheduleTileLoads();
}

function scheduleTileLoads() {
  const maxSlots = tileConcurrencyLimit();
  while (state.inflightTileTasks.size < maxSlots && state.tileVisibleQueue.length > 0) {
    const nextVisible = state.tileVisibleQueue.shift();
    startTileTask(nextVisible);
  }
  if (state.lightboxOpen) return;
  const visiblePending = state.tileVisibleQueue.length;
  const prefetchBudget = visiblePending > 0
    ? Math.max(0, maxSlots - Math.min(TILE_VISIBLE_RESERVED_SLOTS, maxSlots))
    : maxSlots;
  while (state.inflightTileTasks.size < prefetchBudget && state.tilePrefetchQueue.length > 0) {
    const nextPrefetch = state.tilePrefetchQueue.shift();
    startTileTask(nextPrefetch);
  }
}

function startTileTask(task) {
  if (!task || (task.state !== 'queued' && task.state !== 'idle')) return;
  const img = task.img;
  const frame = task.frame;
  if (!img || !frame) return;

  task.state = 'loading';
  task.retryCount = task.retryCount || 0;
  const token = `${task.photo?.id || 'p'}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  task.runToken = token;
  state.inflightTileTasks.set(img, task);
  frame.classList.add('loading');
  frame.classList.remove('failed');
  img.fetchPriority = task.priority === 'visible' ? 'high' : 'low';
  img.decoding = 'async';
  const source = task.thumbSrc;

  const finish = (ok) => {
    if (task.runToken !== token) return;
    if (task.retryTimer) {
      clearTimeout(task.retryTimer);
      task.retryTimer = null;
    }
    img.onload = null;
    img.onerror = null;
    state.inflightTileTasks.delete(img);
    frame.classList.remove('loading');
    if (ok) {
      task.state = 'done';
      img.dataset.loadedSrc = img.currentSrc || img.src || source || '';
      frame.classList.remove('failed');
    } else {
      task.state = 'failed';
      frame.classList.add('failed');
    }
    task.runToken = '';
    scheduleTileLoads();
  };

  img.onload = () => finish(true);
  img.onerror = () => {
    if (task.runToken !== token) return;
    if (task.retryCount < 1) {
      task.retryCount += 1;
      task.retryTimer = window.setTimeout(() => {
        if (task.runToken !== token) return;
        img.src = source;
      }, TILE_RETRY_DELAY_MS);
      return;
    }
    finish(false);
  };
  img.src = source;
}

const tileVisibleObserver = 'IntersectionObserver' in window
  ? new IntersectionObserver((entries) => {
    for (const entry of entries) {
      const task = tileTaskByImg.get(entry.target);
      if (!task) continue;
      if (entry.isIntersecting) {
        promoteTileTask(task);
      }
    }
  }, { rootMargin: TILE_VISIBLE_ROOT_MARGIN, threshold: 0.01 })
  : null;

const tilePrefetchObserver = 'IntersectionObserver' in window
  ? new IntersectionObserver((entries) => {
    for (const entry of entries) {
      const task = tileTaskByImg.get(entry.target);
      if (!task) continue;
      if (entry.isIntersecting) {
        if (task.state === 'idle' && task.priority !== 'visible') {
          enqueueTileTask(task, 'prefetch');
        }
      } else if (!isTaskVisible(task) && task.priority !== 'visible' && task.state === 'queued') {
        removeTaskFromQueue(state.tilePrefetchQueue, task);
        task.state = 'idle';
      }
    }
  }, { rootMargin: TILE_PREFETCH_ROOT_MARGIN, threshold: 0.01 })
  : null;

function observeTileTask(task) {
  if (!task?.img) return;
  if (tileVisibleObserver) tileVisibleObserver.observe(task.img);
  if (tilePrefetchObserver) tilePrefetchObserver.observe(task.img);
}

function pruneQueuedTileTasks() {
  const vh = window.innerHeight || document.documentElement.clientHeight || 1;
  for (const task of [...state.tilePrefetchQueue]) {
    if (!task?.img || task.state !== 'queued') continue;
    const rect = task.img.getBoundingClientRect();
    if (rect.bottom < -2 * vh) {
      removeTaskFromQueue(state.tilePrefetchQueue, task);
      task.state = 'idle';
    } else {
      task.distancePx = taskDistancePx(task);
    }
  }
}

let pruneTileTimer = 0;
function schedulePruneQueuedTileTasks() {
  if (pruneTileTimer) return;
  pruneTileTimer = window.setTimeout(() => {
    pruneTileTimer = 0;
    pruneQueuedTileTasks();
  }, 120);
}

function clearTileSchedulingContext() {
  if (tileVisibleObserver || tilePrefetchObserver) {
    document.querySelectorAll('#photo-grid img[data-photo-id]').forEach((img) => {
      if (tileVisibleObserver) tileVisibleObserver.unobserve(img);
      if (tilePrefetchObserver) tilePrefetchObserver.unobserve(img);
      const task = tileTaskByImg.get(img);
      if (!task) return;
      task.runToken = '';
      if (task.retryTimer) {
        clearTimeout(task.retryTimer);
        task.retryTimer = null;
      }
      img.onload = null;
      img.onerror = null;
    });
  }
  state.tileVisibleQueue = [];
  state.tilePrefetchQueue = [];
  state.inflightTileTasks.clear();
  state.suspendedByLightbox.clear();
}

function qs(id) { return document.getElementById(id); }

async function api(path, options = {}) {
  const res = await fetch(path, options);
  if (res.status === 401) {
    window.location.href = '/login';
    throw new Error('未登录');
  }
  if (!res.ok) {
    let msg = '请求失败';
    try {
      const data = await res.json();
      msg = data.error || msg;
    } catch (_e) {}
    throw new Error(msg);
  }
  const contentType = res.headers.get('content-type') || '';
  if (contentType.includes('application/json')) return res.json();
  return null;
}

function goAdmin() { window.location.href = '/admin'; }

async function logout() {
  await api('/api/auth/logout', { method: 'POST' });
  window.location.href = '/login';
}

function updateHeader() {
  qs('user-info').textContent = `${CURRENT_USER.username} · ${CURRENT_USER.role === 'admin' ? '管理员' : '用户'}`;
  if (CURRENT_USER.role === 'admin') {
    qs('admin-btn').style.display = 'inline-flex';
    qs('refresh-btn').style.display = 'inline-flex';
    qs('scan-live').style.display = 'inline-flex';
  }
}

async function updateScanLive() {
  if (CURRENT_USER.role !== 'admin') return;
  try {
    const s = await api('/api/admin/scan-status');
    const scanTotal = s.scan_target_albums || s.found_albums || 0;
    const scanDone = s.scan_done_albums || ((s.processed_albums || 0) + (s.skipped_albums || 0));
    const scanPct = s.scan_progress_pct || 0;

    const transTotal = s.total_cache_tasks || 0;
    const transDone = s.transcode_done_tasks || s.completed_cache_tasks || 0;
    const transPct = s.transcode_progress_pct || 0;

    if (s.running) {
      qs('scan-live').textContent = `扫描 ${scanDone}/${scanTotal} (${scanPct}%) · 转码 ${transDone}/${transTotal} (${transPct}%)`;
    } else {
      qs('scan-live').textContent = '扫描空闲';
    }
  } catch (_e) {
    qs('scan-live').textContent = '进度获取失败';
  }
}

function updateBreadcrumb() {
  const bc = [];
  bc.push(`<span class="clickable" onclick="openYears()">全部年份</span>`);
  if (state.year) {
    bc.push('›');
    bc.push(
      `<span class="clickable" data-year="${encodeURIComponent(state.year)}" onclick="openYearFromEl(this)">${escapeHtml(state.year)}</span>`
    );
  }
  if (state.albumId) {
    bc.push('›');
    bc.push(`<span class="clickable" onclick="openAlbumRoot()">${escapeHtml(state.albumName || '相册')}</span>`);
    if (state.folderPath) {
      const parts = state.folderPath.split('/').filter(Boolean);
      let current = '';
      for (const part of parts) {
        current = current ? `${current}/${part}` : part;
        bc.push('›');
        bc.push(
          `<span class="clickable" data-folder="${encodeURIComponent(current)}" onclick="openFolderFromEl(this)">${escapeHtml(part)}</span>`
        );
      }
    }
  }
  qs('breadcrumb').innerHTML = bc.join(' ');
}

function setTitle(title, subtitle) {
  qs('title').textContent = title;
  qs('subtitle').textContent = subtitle || '';
}

function escapeHtml(v) {
  return String(v)
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');
}

async function loadStats() {
  try {
    const s = await api('/api/stats');
    qs('stats').textContent = `${s.albums} 个项目 · ${s.photos.toLocaleString()} 张 · ${s.total_size_gb} GB`;
  } catch (_e) {
    qs('stats').textContent = '统计加载失败';
  }
}

function renderEmpty(msg) {
  qs('content').innerHTML = `<div class="empty">${escapeHtml(msg)}</div>`;
}

function placeholder(text) {
  return `<div class="cover-placeholder">${escapeHtml(text)}</div>`;
}

function decodeURIComponentSafe(value) {
  try {
    return decodeURIComponent(String(value || ''));
  } catch (_e) {
    return String(value || '');
  }
}

function showActionError(prefix, error) {
  const msg = String(error?.message || error || '请求失败');
  alert(`${prefix}: ${msg}`);
}

function setLightboxStage(stage, status, text) {
  stage.classList.remove('loading', 'ready', 'error');
  stage.classList.add(status);
  qs('lb-stage-msg').textContent = text || '';
}

function versionToken(value) {
  if (value === null || value === undefined || value === '') return '';
  const numeric = Number(value);
  if (Number.isFinite(numeric) && numeric > 0) return String(Math.floor(numeric));
  return encodeURIComponent(String(value));
}

function withVersion(url, value) {
  const token = versionToken(value);
  if (!token) return url;
  const joiner = url.includes('?') ? '&' : '?';
  return `${url}${joiner}v=${token}`;
}

function previewUrl(photo, highPriority = false) {
  let url = withVersion(`/api/preview/${photo.id}`, photo?.mtime);
  if (highPriority) {
    const joiner = url.includes('?') ? '&' : '?';
    url = `${url}${joiner}priority=high`;
  }
  return url;
}

function thumbUrl(photo) {
  return withVersion(`/api/thumb/${photo.id}`, photo?.mtime);
}

function thumbUrlById(photoId, mtime) {
  return withVersion(`/api/thumb/${photoId}`, mtime);
}

function fallbackOriginalUrl(photo) {
  return withVersion(`/api/download/${photo.id}?inline=1`, photo?.mtime);
}

function bindTileImage(img, photo, eager = false) {
  const frame = img?.closest('.photo-frame');
  if (!frame || !photo) return;
  const task = {
    img,
    frame,
    photo,
    thumbSrc: thumbUrl(photo),
    state: 'idle',
    priority: eager ? 'visible' : 'prefetch',
    retryCount: 0,
    retryTimer: null,
    queuedAt: 0,
    distancePx: 0,
    runToken: '',
  };
  tileTaskByImg.set(img, task);
  img.dataset.photoId = String(photo.id);
  img.dataset.thumbSrc = task.thumbSrc;
  img.dataset.loadedSrc = '';
  img.loading = 'eager';
  img.decoding = 'async';
  img.fetchPriority = eager ? 'high' : 'low';

  if (eager || !tileVisibleObserver || !tilePrefetchObserver) {
    promoteTileTask(task);
  } else {
    observeTileTask(task);
  }
}

function getCachedLightboxPreview(photoId) {
  return state.lightboxPreviewCache.get(photoId) || '';
}

function putCachedLightboxPreview(photoId, objectUrl) {
  if (!photoId || !objectUrl) return;
  const existing = state.lightboxPreviewCache.get(photoId);
  if (existing && existing !== objectUrl) {
    try { URL.revokeObjectURL(existing); } catch (_e) {}
  }
  state.lightboxPreviewCache.set(photoId, objectUrl);
  state.lightboxPreviewOrder = state.lightboxPreviewOrder.filter((id) => id !== photoId);
  state.lightboxPreviewOrder.push(photoId);
  while (state.lightboxPreviewOrder.length > LIGHTBOX_PREFETCH_CACHE_LIMIT) {
    const evictId = state.lightboxPreviewOrder.shift();
    if (!evictId) continue;
    const evictUrl = state.lightboxPreviewCache.get(evictId);
    if (evictUrl) {
      try { URL.revokeObjectURL(evictUrl); } catch (_e) {}
    }
    state.lightboxPreviewCache.delete(evictId);
  }
}

function revokeAllLightboxCachedPreviews() {
  for (const url of state.lightboxPreviewCache.values()) {
    try { URL.revokeObjectURL(url); } catch (_e) {}
  }
  state.lightboxPreviewCache.clear();
  state.lightboxPreviewOrder = [];
}

function abortLightboxMainFetch() {
  if (state.lightboxMainController) {
    try { state.lightboxMainController.abort(); } catch (_e) {}
    state.lightboxMainController = null;
  }
}

function abortLightboxPrefetchFetch() {
  if (state.lightboxPrefetchController) {
    try { state.lightboxPrefetchController.abort(); } catch (_e) {}
    state.lightboxPrefetchController = null;
  }
}

function clearLightboxPrefetchQueue() {
  state.lightboxPrefetchQueue = [];
}

function enqueueLightboxPrefetch(photo) {
  if (!photo?.id || !state.lightboxOpen) return;
  if (state.lightboxPreviewCache.has(photo.id)) return;
  if (state.lightboxPrefetchQueue.some((p) => p?.id === photo.id)) return;
  state.lightboxPrefetchQueue.push(photo);
  runLightboxPrefetchQueue();
}

async function runLightboxPrefetchQueue() {
  if (!state.lightboxOpen) return;
  if (state.lightboxPrefetchInFlight >= LIGHTBOX_PREFETCH_CONCURRENCY) return;
  const nextPhoto = state.lightboxPrefetchQueue.shift();
  if (!nextPhoto?.id) return;
  if (state.lightboxPreviewCache.has(nextPhoto.id)) {
    runLightboxPrefetchQueue();
    return;
  }
  state.lightboxPrefetchInFlight += 1;
  const controller = new AbortController();
  state.lightboxPrefetchController = controller;
  try {
    const res = await fetch(previewUrl(nextPhoto), { signal: controller.signal, cache: 'force-cache', priority: 'low' });
    if (!res.ok) throw new Error(`http_${res.status}`);
    const blob = await res.blob();
    if (!state.lightboxOpen) return;
    const objectUrl = URL.createObjectURL(blob);
    putCachedLightboxPreview(nextPhoto.id, objectUrl);
  } catch (_e) {
    // best effort prefetch
  } finally {
    state.lightboxPrefetchInFlight = Math.max(0, state.lightboxPrefetchInFlight - 1);
    if (state.lightboxPrefetchController === controller) {
      state.lightboxPrefetchController = null;
    }
    if (state.lightboxOpen) runLightboxPrefetchQueue();
  }
}

function queueLightboxNeighborPrefetch(centerIndex) {
  const total = state.photos.length;
  if (total <= 1) return;
  const next = state.photos[(centerIndex + 1) % total];
  const prev = state.photos[(centerIndex - 1 + total) % total];
  enqueueLightboxPrefetch(next);
  enqueueLightboxPrefetch(prev);
}

function openYearFromEl(el) {
  const year = decodeURIComponentSafe(el?.dataset?.year).trim();
  if (!year) return;
  openYear(year).catch((e) => showActionError('打开年份失败', e));
}

function openAlbumFromEl(el) {
  const albumId = Number(el?.dataset?.albumId || 0);
  if (!Number.isFinite(albumId) || albumId <= 0) return;
  const albumName = decodeURIComponentSafe(el?.dataset?.albumName);
  openAlbum(albumId, albumName).catch((e) => showActionError('打开相册失败', e));
}

function openAlbumRoot() {
  if (!state.albumId) return;
  openFolder('').catch((e) => showActionError('打开相册根目录失败', e));
}

function openFolderFromEl(el) {
  const folder = decodeURIComponentSafe(el?.dataset?.folder).trim();
  openFolder(folder).catch((e) => showActionError('打开子文件夹失败', e));
}

async function openYears() {
  clearTileSchedulingContext();
  state.view = 'years';
  state.year = '';
  state.albumId = null;
  state.albumName = '';
  state.folderPath = '';
  updateBreadcrumb();
  setTitle('年份', '按年份浏览已索引项目');

  qs('content').innerHTML = '<div class="empty">正在加载...</div>';
  const data = await api('/api/years');
  state.years = data.years || [];

  if (!state.years.length) {
    renderEmpty('暂无可见项目。请让管理员先扫描并发布相册。');
    updateHash();
    return;
  }

  let html = '<div class="grid years">';
  for (const y of state.years) {
    const cover = y.cover_photo_id ? thumbUrlById(y.cover_photo_id, y.cover_photo_mtime) : '';
    const yearEncoded = encodeURIComponent(String(y.year || ''));
    html += `
      <article class="card" data-year="${yearEncoded}" onclick="openYearFromEl(this)">
        <div class="cover">
          ${cover ? `<img loading="lazy" decoding="async" src="${cover}" alt="${escapeHtml(y.year)}">` : placeholder('无封面')}
        </div>
        <div class="card-body">
          <div class="name">${escapeHtml(y.year)}</div>
          <div class="meta">${y.albums} 个项目 · ${Number(y.photos).toLocaleString()} 张</div>
        </div>
      </article>`;
  }
  html += '</div>';
  qs('content').innerHTML = html;
  updateHash();
}

async function openYear(year) {
  clearTileSchedulingContext();
  state.view = 'albums';
  state.year = year;
  state.albumId = null;
  state.albumName = '';
  state.folderPath = '';
  updateBreadcrumb();
  const subtitle = state.query ? `搜索 “${state.query}”` : `年份 ${year}`;
  setTitle(year, subtitle);

  qs('content').innerHTML = '<div class="empty">正在加载...</div>';
  const query = new URLSearchParams();
  query.set('year', year);
  if (state.query) query.set('q', state.query);

  const data = await api(`/api/albums?${query.toString()}`);
  state.albums = data.albums || [];

  if (!state.albums.length) {
    renderEmpty('当前条件下没有相册。');
    updateHash();
    return;
  }

  let html = '<div class="grid albums">';
  for (const a of state.albums) {
    const cover = withVersion(`/api/cover/${a.id}`, a.updated_at);
    const albumNameEncoded = encodeURIComponent(String(a.name || ''));
    const publishTag = CURRENT_USER.role === 'admin'
      ? `<span class="tag" style="background:${a.published ? 'rgba(16,185,129,.86)' : 'rgba(245,158,11,.86)'};">${a.published ? '已发布' : '未发布'}</span>`
      : '';

    html += `
      <article class="card" data-album-id="${a.id}" data-album-name="${albumNameEncoded}" onclick="openAlbumFromEl(this)">
        <div class="cover">
          <img loading="lazy" decoding="async" src="${cover}" alt="${escapeHtml(a.name)}">
          ${publishTag}
        </div>
        <div class="card-body">
          <div class="name">${escapeHtml(a.name)}</div>
          <div class="meta">${a.photo_count} 张 · ${escapeHtml(a.rel_path)}</div>
        </div>
      </article>`;
  }
  html += '</div>';
  qs('content').innerHTML = html;
  updateHash();
}

async function openAlbum(albumId, albumName, folderPath = '') {
  state.view = 'photos';
  state.albumId = albumId;
  state.albumName = albumName || '';
  state.folderPath = String(folderPath || '').trim().replaceAll('\\', '/').replace(/^\/+|\/+$/g, '');
  state.photos = [];
  state.page = 1;
  state.hasMore = false;
  updateBreadcrumb();
  setTitle(state.albumName || '相册', '正在加载照片...');

  qs('content').innerHTML = '<div class="empty">正在加载...</div>';
  await loadPhotoPage(true);
  updateHash();
}

async function openFolder(folderPath = '') {
  if (!state.albumId) return;
  state.folderPath = String(folderPath || '').trim().replaceAll('\\', '/').replace(/^\/+|\/+$/g, '');
  state.photos = [];
  state.page = 1;
  state.hasMore = false;
  updateBreadcrumb();
  setTitle(state.albumName || '相册', '正在加载目录...');
  qs('content').innerHTML = '<div class="empty">正在加载目录...</div>';
  await loadPhotoPage(true);
  updateHash();
}

async function loadPhotoPage(reset = false) {
  if (state.loading || !state.albumId) return;
  state.loading = true;

  try {
    const q = new URLSearchParams({
      album_id: String(state.albumId),
      page: String(state.page),
      page_size: String(state.pageSize),
    });
    if (state.folderPath) q.set('folder', state.folderPath);

    const data = await api(`/api/photos?${q.toString()}`);

    if (reset) {
      clearTileSchedulingContext();
      state.photos = [];
      qs('content').innerHTML = '<div class="folder-grid" id="folder-grid"></div><div class="photo-masonry" id="photo-grid"></div><div class="load-more" id="load-more"></div>';
    }

    state.folderPath = String(data.folder || '');
    state.photos = state.photos.concat(data.photos || []);
    state.hasMore = !!data.has_more;
    state.albumName = data.album?.name || state.albumName;

    const folderName = state.folderPath ? state.folderPath.split('/').filter(Boolean).pop() : (state.albumName || '相册');
    const folderCount = Number(data.folder_count || 0);
    const totalDirect = Number(data.total || 0);
    const totalRecursive = Number(data.total_recursive || totalDirect);
    setTitle(
      folderName || (state.albumName || '相册'),
      `当前目录: ${folderCount} 个子文件夹 · ${totalDirect} 张直系照片（累计 ${totalRecursive} 张）`
    );
    updateBreadcrumb();

    if (reset) {
      const folderGrid = qs('folder-grid');
      const folders = Array.isArray(data.folders) ? data.folders : [];
      if (folders.length) {
        let folderHtml = '';
        for (const f of folders) {
          const folderPathEncoded = encodeURIComponent(String(f.path || ''));
          const cover = f.cover_photo_id ? thumbUrlById(f.cover_photo_id, f.cover_photo_mtime) : '';
          folderHtml += `
            <article class="card folder-card" data-folder="${folderPathEncoded}" onclick="openFolderFromEl(this)">
              <div class="cover">
                ${cover ? `<img loading="lazy" decoding="async" src="${cover}" alt="${escapeHtml(f.name || '子文件夹')}">` : placeholder('子文件夹')}
              </div>
              <div class="card-body">
                <div class="name">${escapeHtml(f.name || '未命名子文件夹')}</div>
                <div class="meta">${Number(f.photo_count || 0)} 张</div>
              </div>
            </article>`;
        }
        folderGrid.innerHTML = folderHtml;
      } else {
        folderGrid.innerHTML = '';
      }
    }

    const grid = qs('photo-grid');
    const photoBatch = Array.isArray(data.photos) ? data.photos : [];
    const fragment = document.createDocumentFragment();
    for (let idx = 0; idx < photoBatch.length; idx += 1) {
      const p = photoBatch[idx];
      const tile = document.createElement('article');
      tile.className = 'photo-tile';
      tile.innerHTML = `
        <div class="photo-frame">
          <img decoding="async" alt="${escapeHtml(p.filename)}">
        </div>
        <div class="photo-meta">
          <div class="photo-filename">${escapeHtml(p.filename)}</div>
          <div class="photo-size">${Number(p.size_mb).toFixed(2)} MB</div>
        </div>
      `;
      const img = tile.querySelector('img');
      tile.onclick = () => openLightboxById(p.id, img);
      const eager = reset && idx < TILE_EAGER_COUNT;
      img.fetchPriority = eager ? 'high' : 'low';
      bindTileImage(img, p, eager);
      fragment.appendChild(tile);
    }
    grid.appendChild(fragment);
    scheduleTileLoads();

    if (reset && Number(data.folder_count || 0) === 0 && Number(data.total || 0) === 0) {
      renderEmpty('当前目录为空');
      return;
    }

    const more = qs('load-more');
    if (state.hasMore) {
      more.innerHTML = '<button class="btn primary" onclick="loadMorePhotos()">加载更多</button>';
    } else if (Number(data.total || 0) === 0 && Number(data.folder_count || 0) > 0) {
      more.innerHTML = '<span class="badge">当前目录无直系照片</span>';
    } else {
      more.innerHTML = '<span class="badge">已加载全部照片</span>';
    }
  } finally {
    state.loading = false;
  }
}

function loadMorePhotos() {
  state.page += 1;
  loadPhotoPage(false);
}

function resolveLightboxPlaceholder(photo, sourceImg = null) {
  const src = sourceImg?.dataset?.loadedSrc || sourceImg?.currentSrc || sourceImg?.src || '';
  if (src) return src;
  if (!photo?.id) return '';
  const img = document.querySelector(`#photo-grid img[data-photo-id="${photo.id}"]`);
  return img?.dataset?.loadedSrc || img?.currentSrc || img?.dataset?.thumbSrc || thumbUrl(photo);
}

function applyLightboxErrorFallback(img, stage, token, photo) {
  if (state.lightboxRenderToken !== token) return;
  if (img.dataset.fallbackTried === '1') {
    setLightboxStage(stage, 'error', '图片加载失败，可点击“下载原图”');
    return;
  }
  img.dataset.fallbackTried = '1';
  setLightboxStage(stage, 'loading', '预览异常，切换原图...');
  img.onload = () => {
    if (state.lightboxRenderToken !== token) return;
    setLightboxStage(stage, 'ready', '');
  };
  img.onerror = () => {
    if (state.lightboxRenderToken !== token) return;
    setLightboxStage(stage, 'error', '图片加载失败，可点击“下载原图”');
  };
  img.src = fallbackOriginalUrl(photo);
}

function bindLightboxImageHandlers(img, stage, token, photo) {
  img.onload = () => {
    if (state.lightboxRenderToken !== token) return;
    setLightboxStage(stage, 'ready', '');
    queueLightboxNeighborPrefetch(state.lightboxIndex);
  };
  img.onerror = () => {
    applyLightboxErrorFallback(img, stage, token, photo);
  };
}

function openLightboxById(photoId, sourceImg = null) {
  const idx = state.photos.findIndex(p => p.id === photoId);
  if (idx < 0) return;
  state.lightboxIndex = idx;
  state.lightboxOpen = true;
  state.lightboxPlaceholderSrc = resolveLightboxPlaceholder(state.photos[idx], sourceImg);
  qs('lightbox').classList.add('show');
  document.body.style.overflow = 'hidden';
  suspendLowPriorityTilesForLightbox();
  renderLightbox();
}

function closeLightbox() {
  state.lightboxOpen = false;
  qs('lightbox').classList.remove('show');
  state.lightboxRenderToken = '';
  abortLightboxMainFetch();
  abortLightboxPrefetchFetch();
  clearLightboxPrefetchQueue();
  state.lightboxPrefetchInFlight = 0;
  state.lightboxPlaceholderSrc = '';
  revokeAllLightboxCachedPreviews();
  document.body.style.overflow = '';
  restoreSuspendedTiles();
  scheduleTileLoads();
}

function stepLightbox(delta) {
  if (!state.photos.length) return;
  state.lightboxIndex = (state.lightboxIndex + delta + state.photos.length) % state.photos.length;
  state.lightboxPlaceholderSrc = resolveLightboxPlaceholder(state.photos[state.lightboxIndex]);
  renderLightbox();
}

function renderLightbox() {
  const p = state.photos[state.lightboxIndex];
  if (!p) return;
  const img = qs('lb-img');
  const stage = qs('lb-stage');
  const token = `${p.id}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  state.lightboxRenderToken = token;
  abortLightboxMainFetch();
  img.fetchPriority = 'high';
  clearLightboxPrefetchQueue();

  setLightboxStage(stage, 'loading', '加载高清预览中...');
  img.dataset.token = token;
  img.dataset.fallbackTried = '0';
  qs('lb-title').textContent = p.filename;
  qs('lb-counter').textContent = `${state.lightboxIndex + 1} / ${state.photos.length}`;

  const cachedPreview = getCachedLightboxPreview(p.id);
  bindLightboxImageHandlers(img, stage, token, p);
  if (cachedPreview) {
    img.src = cachedPreview;
    if (img.complete && img.naturalWidth > 0) {
      setLightboxStage(stage, 'ready', '');
      queueLightboxNeighborPrefetch(state.lightboxIndex);
    }
    return;
  }

  const placeholder = state.lightboxPlaceholderSrc || thumbUrl(p);
  if (placeholder) img.src = placeholder;

  const controller = new AbortController();
  state.lightboxMainController = controller;
  fetch(previewUrl(p, true), { signal: controller.signal, cache: 'force-cache', priority: 'high' })
    .then((res) => {
      if (!res.ok) throw new Error(`http_${res.status}`);
      return res.blob();
    })
    .then((blob) => {
      if (state.lightboxRenderToken !== token || !state.lightboxOpen) return;
      const objectUrl = URL.createObjectURL(blob);
      putCachedLightboxPreview(p.id, objectUrl);
      bindLightboxImageHandlers(img, stage, token, p);
      img.src = objectUrl;
    })
    .catch((err) => {
      if (controller.signal.aborted) return;
      if (state.lightboxRenderToken !== token) return;
      if (String(err?.name || '') === 'AbortError') return;
      applyLightboxErrorFallback(img, stage, token, p);
    })
    .finally(() => {
      if (state.lightboxMainController === controller) {
        state.lightboxMainController = null;
      }
    });
}

function downloadCurrent() {
  const p = state.photos[state.lightboxIndex];
  if (!p) return;
  window.open(`/api/download/${p.id}`, '_blank');
}

async function triggerScan() {
  if (CURRENT_USER.role !== 'admin') return;
  const button = qs('refresh-btn');
  button.disabled = true;
  button.textContent = '扫描中...';
  try {
    await api('/api/admin/albums/scan', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ force: false })
    });
    setTimeout(loadStats, 1200);
  } catch (e) {
    alert(`扫描启动失败: ${e.message}`);
  } finally {
    setTimeout(() => {
      button.disabled = false;
      button.textContent = '增量扫描';
    }, 2000);
  }
}

function updateHash() {
  if (state.view === 'years') {
    history.replaceState(null, '', '#/years');
  } else if (state.view === 'albums') {
    history.replaceState(null, '', `#/year/${encodeURIComponent(state.year)}`);
  } else if (state.view === 'photos') {
    if (state.folderPath) {
      history.replaceState(null, '', `#/album/${state.albumId}/${encodeURIComponent(state.folderPath)}`);
    } else {
      history.replaceState(null, '', `#/album/${state.albumId}`);
    }
  }
}

async function restoreFromHash() {
  const hash = location.hash.replace('#', '');
  if (!hash || hash === '/years') {
    await openYears();
    return;
  }

  const parts = hash.split('/').filter(Boolean);
  if (parts[0] === 'year' && parts[1]) {
    await openYear(decodeURIComponent(parts[1]));
    return;
  }

  if (parts[0] === 'album' && parts[1]) {
    const albumId = Number(parts[1]);
    if (!Number.isFinite(albumId) || albumId <= 0) {
      await openYears();
      return;
    }
    const folderPath = decodeURIComponentSafe(parts.slice(2).join('/'));
    await openAlbum(albumId, '相册', folderPath);
    return;
  }

  await openYears();
}

function bindEvents() {
  qs('search').addEventListener('keydown', async (e) => {
    if (e.key === 'Enter') {
      state.query = e.target.value.trim();
      if (state.view === 'albums' && state.year) {
        await openYear(state.year);
      }
    }
  });

  document.addEventListener('keydown', (e) => {
    const showing = qs('lightbox').classList.contains('show');
    if (!showing) return;
    if (e.key === 'Escape') closeLightbox();
    if (e.key === 'ArrowLeft') stepLightbox(-1);
    if (e.key === 'ArrowRight') stepLightbox(1);
    if (e.key.toLowerCase() === 'd') downloadCurrent();
  });

  window.addEventListener('scroll', () => {
    schedulePruneQueuedTileTasks();
    scheduleTileLoads();
  }, { passive: true });

  window.addEventListener('resize', () => {
    schedulePruneQueuedTileTasks();
    scheduleTileLoads();
  }, { passive: true });
}

(async function init() {
  updateHeader();
  bindEvents();
  await loadStats();
  if (CURRENT_USER.role === 'admin') {
    await updateScanLive();
    setInterval(() => { updateScanLive().catch(() => {}); }, 5000);
  }
  await restoreFromHash();
})();
</script>
</body>
</html>
